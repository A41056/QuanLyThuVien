

Use this...			Instead of this...		When wishing to do this...
await			Task.Wait or Task.Result	Retrieving the result of a background task
await Task.WhenAny		Task.WaitAny		Waiting for any task to complete
await Task.WhenAll		Task.WaitAll		Waiting for all tasks to complete
await Task.Delay		Thread.Sleep		Waiting for a period of time



Không bao h dùng async void

-> 1 số cách thay thế async void: 
+, chuyển về thành hàm void, khi gọi method async có thể đi kèm Task.WhenAny()/WhenAll() hoặc ContinueWith() tùy mục đích

Không sử dụng Task lồng Task. VD: Task.Run(() => 1 task khác);

Tác dụng 1 số hàm: 
.ContinueWith(.....) : ..... chỉ được chạy khi hàm trước đó complete, có 1 số TaskContinuationOpntions cần tìm hiểu, có thể xử lý kết quả trong ........

Task.WhenAll(), WhenAny(): chạy song song các task và trả về 1 task, whenany trả về int.

Task.Start(), Task.Run(), Task.Factory.StartNew(): Task.Run() gần tương đương Task.Factory.StartNew(), Task.StartNew() có nhiều option tùy chỉnh hơn. Không nên dùng Task.Start().
Ưu tiên sử dụng Task.Run(), chỉ sử dụng Task.StartNew() khi có nhiều nhiệm vụ con lồng nhau phức tạp.

parentTask.Wait() nếu sử dụng Task.Run() thì Task con sẽ không đc "wait" vì Task.Run() có TaskCreationOptions = DenyChildAttach.

Task.StartNew() thì ngược lại.	


từ khóa async không giúp 1 hàm thành bất đồng bộ.

Wait() 1 task có await Task.Delay(...) sẽ tạo deadlock trong Winform vì .Wait()
 sẽ chờ kết quả trả về UI Thread, Task.Delay sẽ chờ kết quả trả về UI Thread => 2 cái cứ chờ nhau và sẽ không bao giờ vượt qua đc dòng code đó => deadlock.


Để chờ vô hạn dùng Task.Delay(-1)

Dùng Manifes, mở rào đoạn <application>.....</application> để làm rõ chữ


Kế thừa: Form base không cần label, textbox, xử lý các sự kiện chung ở form base, các form con kế thừa lại thì viết code cụ thể





